var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import Validate from 'validate.js';
var CarmelValidate = {
    isObject: function (item) {
        return (item && typeof item === 'object' && !Array.isArray(item));
    },
    mergeDeep: function (target, source) {
        var _this = this;
        var output = Object.assign({}, target);
        if (this.isObject(target) && this.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                var _a, _b;
                if (_this.isObject(source[key])) {
                    if (!(key in target)) {
                        if (key !== "eTarget") {
                            Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                        }
                    }
                    else {
                        output[key] = _this.mergeDeep(target[key], source[key]);
                    }
                }
                else {
                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));
                }
            });
        }
        return output;
    },
    runValidate: function (data, rules, whitelist, depth) {
        if (rules === void 0) { rules = null; }
        if (whitelist === void 0) { whitelist = null; }
        if (depth === void 0) { depth = 10; }
        if (depth < 0)
            // throw 'TOO DEEP BRO.' + depth;
            throw new Error('TOO DEEP BRO.' + depth);
        if (whitelist) {
            data = Validate.cleanAttributes(data, whitelist);
            // if (rules) rules = Validate.cleanAttributes(rules, whitelist); //clean up rules isnt helping anythig.
        }
        var res;
        if (this.isObject(data)) {
            try {
                if (rules && rules.type) {
                    if (rules.type !== "object" && !this.isObject(rules.type)) {
                        // throw `WANTED ${rules.type} GOT object.`
                        throw new Error("WANTED " + rules.type + " GOT object.");
                    }
                    else
                        delete rules.type; //cannot run that way
                }
                rules = this.createDefaultRules(data, rules, depth);
                res = Validate.validate(data, rules);
            }
            catch (err) {
                console.log(err);
                return { success: 0 };
            }
        }
        else {
            if (rules.eTarget && rules.eTarget.type === 'number' && !data)
                return;
            return this.ValidateVar(data, rules);
        }
        if (res === undefined)
            return { data: data, success: 1 };
        console.log("ERROR:", res);
        return { success: 0 };
    },
    createDefaultRules: function (data, rules, depth, originPath) {
        if (originPath === void 0) { originPath = ""; }
        if (depth < 0)
            throw 'TOO DEEP BRO.' + depth;
        if (!rules)
            rules = {};
        if (this.isObject(data))
            rules = this.getObjectRules(data, rules, depth, originPath);
        else if (Validate.isArray(data))
            rules[originPath] = this.getArrayRules(data, rules[originPath], depth);
        else if (Validate.isDate(data))
            rules[originPath] = this.getDateRules(rules[originPath]);
        else if (Validate.isString(data))
            rules[originPath] = this.getStringRules(rules[originPath], originPath);
        else if (Validate.isNumber(data))
            rules[originPath] = this.getNumberRules(rules[originPath]);
        return rules;
    },
    ValidateVar: function (data, rule) {
        if (this.isObject(data))
            return this.runValidate(data, rule);
        else if (Validate.isArray(data)) {
            Validate.single(data);
        }
        if (Validate.isDate(data))
            rule = this.getDateRules();
        else if (Validate.isString(data)) {
            rule = this.getStringRules(rule);
        }
        else if (Validate.isNumber(data)) {
            rule = this.getNumberRules(rule);
        }
        if (Validate.single(data, rule) === undefined) {
            return { success: 1 };
        }
        else {
            return { success: 0, rule: rule.format ? rule : __assign(__assign({}, rule), { format: { message: "כתובת לא מאומתת" } }) };
        }
    },
    getObjectRules: function (data, rules, depth, originKey) {
        var _this = this;
        if (depth === void 0) { depth = 0; }
        if (originKey === void 0) { originKey = ""; }
        if (depth < 0)
            throw new Error('TOO DEEP BRO.' + depth);
        var keys = Object.keys(data);
        if (keys.length > this.originRules.object.maximum) {
            throw new Error("DATA OUT OF RANGE");
        }
        if (!rules)
            rules = {};
        if (data)
            if (originKey !== "")
                originKey += '.';
        keys.map(function (key) {
            rules = _this.mergeDeep(rules, _this.createDefaultRules(data[key], rules, depth - 1, originKey + key));
        });
        return rules;
    },
    getArrayRules: function (data, rules, depth) {
        if (data.length > 100)
            throw new Error("DATA OUT OF RANGE");
        var extendedRules = {};
        if (rules && rules.extendedRules) {
            extendedRules = rules.extendedRules;
        }
        rules = Validate.cleanAttributes(rules, this.rulesWhitelist);
        if (data.length) {
            var type = typeof data[0];
            var res = void 0;
            for (var i = 0; i < data.length; i++) {
                if (extendedRules.consistent && typeof data[i] !== type)
                    throw new Error("ARRAY DOES NOT CONATINS CONSISTENT DATA");
                //inside extended rules, set rule by index(as 0:{...}) or by setting 'all'. 
                res = this.runValidate(data[i], extendedRules[i] || extendedRules.all, null, depth - 1);
                if (!res.success)
                    throw res;
            }
        }
        return {
            length: { minimum: 0, maximum: 100 }
        };
    },
    getDateRules: function () { },
    getStringRules: function (rule, originPath) {
        if (rule === void 0) { rule = {}; }
        if (originPath === void 0) { originPath = ""; }
        if (originPath.split('.').pop() === "email")
            return { email: true, length: { maximum: 100 } };
        if (rule.email) {
            return this.mergeDeep({
                length: { maximum: 10000 }
            }, rule);
        }
        if (rule.eTarget && rule.eTarget.type === 'password') {
            return this.mergeDeep(this.originRules.password, rule);
        }
        return this.mergeDeep(this.originRules.string, rule);
    },
    getNumberRules: function (rule) {
        if (rule === void 0) { rule = null; }
        if (!rule)
            rule = {};
        rule = Validate.cleanAttributes(rule, this.rulesWhitelist);
        if ((rule.type && rule.type === "number") || !rule.type) {
            var newRules = {
                type: 'number',
                numericality: {
                    greaterThan: -10000000000,
                    lessThanOrEqualTo: 10000000000
                }
            };
            return this.mergeDeep(newRules, rule);
        }
        else
            return rule;
    },
    originRules: {
        array: {
            range: {
                min: 0,
                max: 100
            }
        },
        object: {
            maximum: 30
        },
        number: {
            range: {
                min: -1000000000,
                max: 1000000000
            }
        },
        string: {
            format: {
                pattern: "[a-z0-9א-ת -:._]*",
                flags: "i",
                message: "חייב להכיל אותיות או מספרים בלבד"
            },
            length: { maximum: 10000 }
        },
        password: {
            format: {
                pattern: '(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{8,}',
                message: "הסיסמה חייבת להכיל אות קטנה ואות גדולה באנגלית מספר ולהיות באורך של 8 ספרות "
            },
            length: { maximum: 10000 }
        }
    },
    rulesWhitelist: {
        earliest: true,
        latest: true,
        dateOnly: true,
        equality: true,
        email: true,
        length: true,
        exclusion: true,
        inclusion: true,
        message: true,
        format: true,
        numericality: true,
        presence: true,
        type: true,
        url: true
    }
};
export default CarmelValidate;
// console.log(" WELL,",
//     CarmelValidate.runValidate(
//         {
//             email: "kopgfkdp@fds.com",
//             arr: ["str$$"],
//             username: { ar: { trrt: 4 } },
//             you: 42,
//             password: '230jvjvjve'
//         },
//         {
//             password: { type: 'string', length: { minimum: 3 } },
//             you: {
//                 numericality: {
//                     greaterThan: 32
//                 }
//             },
//             arr: {
//                 extendedRules: {
//                     consistent: false, all: {
//                         type: 'string',
//                         format: {
//                             pattern: "[a-z0-9א-ת $]*",
//                             flags: "i",
//                             message: "hahaha"
//                         },
//                     }
//                 }
//             }
//         }))
//# sourceMappingURL=ValidateTool.js.map