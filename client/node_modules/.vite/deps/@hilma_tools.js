import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-OMFGQDFA.js";

// node_modules/validate.js/validate.js
var require_validate = __commonJS({
  "node_modules/validate.js/validate.js"(exports, module) {
    (function(exports2, module2, define2) {
      "use strict";
      var validate = function(attributes, constraints, options) {
        options = v.extend({}, v.options, options);
        var results = v.runValidations(attributes, constraints, options), attr, validator;
        if (results.some(function(r) {
          return v.isPromise(r.error);
        })) {
          throw new Error("Use validate.async if you want support for promises");
        }
        return validate.processValidationResults(results, options);
      };
      var v = validate;
      v.extend = function(obj) {
        [].slice.call(arguments, 1).forEach(function(source) {
          for (var attr in source) {
            obj[attr] = source[attr];
          }
        });
        return obj;
      };
      v.extend(validate, {
        // This is the version of the library as a semver.
        // The toString function will allow it to be coerced into a string
        version: {
          major: 0,
          minor: 13,
          patch: 1,
          metadata: null,
          toString: function() {
            var version = v.format("%{major}.%{minor}.%{patch}", v.version);
            if (!v.isEmpty(v.version.metadata)) {
              version += "+" + v.version.metadata;
            }
            return version;
          }
        },
        // Below is the dependencies that are used in validate.js
        // The constructor of the Promise implementation.
        // If you are using Q.js, RSVP or any other A+ compatible implementation
        // override this attribute to be the constructor of that promise.
        // Since jQuery promises aren't A+ compatible they won't work.
        Promise: typeof Promise !== "undefined" ? Promise : (
          /* istanbul ignore next */
          null
        ),
        EMPTY_STRING_REGEXP: /^\s*$/,
        // Runs the validators specified by the constraints object.
        // Will return an array of the format:
        //     [{attribute: "<attribute name>", error: "<validation result>"}, ...]
        runValidations: function(attributes, constraints, options) {
          var results = [], attr, validatorName, value, validators, validator, validatorOptions, error;
          if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
            attributes = v.collectFormValues(attributes);
          }
          for (attr in constraints) {
            value = v.getDeepObjectValue(attributes, attr);
            validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
            for (validatorName in validators) {
              validator = v.validators[validatorName];
              if (!validator) {
                error = v.format("Unknown validator %{name}", { name: validatorName });
                throw new Error(error);
              }
              validatorOptions = validators[validatorName];
              validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
              if (!validatorOptions) {
                continue;
              }
              results.push({
                attribute: attr,
                value,
                validator: validatorName,
                globalOptions: options,
                attributes,
                options: validatorOptions,
                error: validator.call(
                  validator,
                  value,
                  validatorOptions,
                  attr,
                  attributes,
                  options
                )
              });
            }
          }
          return results;
        },
        // Takes the output from runValidations and converts it to the correct
        // output format.
        processValidationResults: function(errors, options) {
          errors = v.pruneEmptyErrors(errors, options);
          errors = v.expandMultipleErrors(errors, options);
          errors = v.convertErrorMessages(errors, options);
          var format = options.format || "grouped";
          if (typeof v.formatters[format] === "function") {
            errors = v.formatters[format](errors);
          } else {
            throw new Error(v.format("Unknown format %{format}", options));
          }
          return v.isEmpty(errors) ? void 0 : errors;
        },
        // Runs the validations with support for promises.
        // This function will return a promise that is settled when all the
        // validation promises have been completed.
        // It can be called even if no validations returned a promise.
        async: function(attributes, constraints, options) {
          options = v.extend({}, v.async.options, options);
          var WrapErrors = options.wrapErrors || function(errors) {
            return errors;
          };
          if (options.cleanAttributes !== false) {
            attributes = v.cleanAttributes(attributes, constraints);
          }
          var results = v.runValidations(attributes, constraints, options);
          return new v.Promise(function(resolve, reject) {
            v.waitForResults(results).then(function() {
              var errors = v.processValidationResults(results, options);
              if (errors) {
                reject(new WrapErrors(errors, options, attributes, constraints));
              } else {
                resolve(attributes);
              }
            }, function(err) {
              reject(err);
            });
          });
        },
        single: function(value, constraints, options) {
          options = v.extend({}, v.single.options, options, {
            format: "flat",
            fullMessages: false
          });
          return v({ single: value }, { single: constraints }, options);
        },
        // Returns a promise that is resolved when all promises in the results array
        // are settled. The promise returned from this function is always resolved,
        // never rejected.
        // This function modifies the input argument, it replaces the promises
        // with the value returned from the promise.
        waitForResults: function(results) {
          return results.reduce(function(memo, result) {
            if (!v.isPromise(result.error)) {
              return memo;
            }
            return memo.then(function() {
              return result.error.then(function(error) {
                result.error = error || null;
              });
            });
          }, new v.Promise(function(r) {
            r();
          }));
        },
        // If the given argument is a call: function the and: function return the value
        // otherwise just return the value. Additional arguments will be passed as
        // arguments to the function.
        // Example:
        // ```
        // result('foo') // 'foo'
        // result(Math.max, 1, 2) // 2
        // ```
        result: function(value) {
          var args = [].slice.call(arguments, 1);
          if (typeof value === "function") {
            value = value.apply(null, args);
          }
          return value;
        },
        // Checks if the value is a number. This function does not consider NaN a
        // number like many other `isNumber` functions do.
        isNumber: function(value) {
          return typeof value === "number" && !isNaN(value);
        },
        // Returns false if the object is not a function
        isFunction: function(value) {
          return typeof value === "function";
        },
        // A simple check to verify that the value is an integer. Uses `isNumber`
        // and a simple modulo check.
        isInteger: function(value) {
          return v.isNumber(value) && value % 1 === 0;
        },
        // Checks if the value is a boolean
        isBoolean: function(value) {
          return typeof value === "boolean";
        },
        // Uses the `Object` function to check if the given argument is an object.
        isObject: function(obj) {
          return obj === Object(obj);
        },
        // Simply checks if the object is an instance of a date
        isDate: function(obj) {
          return obj instanceof Date;
        },
        // Returns false if the object is `null` of `undefined`
        isDefined: function(obj) {
          return obj !== null && obj !== void 0;
        },
        // Checks if the given argument is a promise. Anything with a `then`
        // function is considered a promise.
        isPromise: function(p) {
          return !!p && v.isFunction(p.then);
        },
        isJqueryElement: function(o) {
          return o && v.isString(o.jquery);
        },
        isDomElement: function(o) {
          if (!o) {
            return false;
          }
          if (!o.querySelectorAll || !o.querySelector) {
            return false;
          }
          if (v.isObject(document) && o === document) {
            return true;
          }
          if (typeof HTMLElement === "object") {
            return o instanceof HTMLElement;
          } else {
            return o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
          }
        },
        isEmpty: function(value) {
          var attr;
          if (!v.isDefined(value)) {
            return true;
          }
          if (v.isFunction(value)) {
            return false;
          }
          if (v.isString(value)) {
            return v.EMPTY_STRING_REGEXP.test(value);
          }
          if (v.isArray(value)) {
            return value.length === 0;
          }
          if (v.isDate(value)) {
            return false;
          }
          if (v.isObject(value)) {
            for (attr in value) {
              return false;
            }
            return true;
          }
          return false;
        },
        // Formats the specified strings with the given values like so:
        // ```
        // format("Foo: %{foo}", {foo: "bar"}) // "Foo bar"
        // ```
        // If you want to write %{...} without having it replaced simply
        // prefix it with % like this `Foo: %%{foo}` and it will be returned
        // as `"Foo: %{foo}"`
        format: v.extend(function(str, vals) {
          if (!v.isString(str)) {
            return str;
          }
          return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {
            if (m1 === "%") {
              return "%{" + m2 + "}";
            } else {
              return String(vals[m2]);
            }
          });
        }, {
          // Finds %{key} style patterns in the given string
          FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g
        }),
        // "Prettifies" the given string.
        // Prettifying means replacing [.\_-] with spaces as well as splitting
        // camel case words.
        prettify: function(str) {
          if (v.isNumber(str)) {
            if (str * 100 % 1 === 0) {
              return "" + str;
            } else {
              return parseFloat(Math.round(str * 100) / 100).toFixed(2);
            }
          }
          if (v.isArray(str)) {
            return str.map(function(s) {
              return v.prettify(s);
            }).join(", ");
          }
          if (v.isObject(str)) {
            if (!v.isDefined(str.toString)) {
              return JSON.stringify(str);
            }
            return str.toString();
          }
          str = "" + str;
          return str.replace(/([^\s])\.([^\s])/g, "$1 $2").replace(/\\+/g, "").replace(/[_-]/g, " ").replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {
            return "" + m1 + " " + m2.toLowerCase();
          }).toLowerCase();
        },
        stringifyValue: function(value, options) {
          var prettify = options && options.prettify || v.prettify;
          return prettify(value);
        },
        isString: function(value) {
          return typeof value === "string";
        },
        isArray: function(value) {
          return {}.toString.call(value) === "[object Array]";
        },
        // Checks if the object is a hash, which is equivalent to an object that
        // is neither an array nor a function.
        isHash: function(value) {
          return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
        },
        contains: function(obj, value) {
          if (!v.isDefined(obj)) {
            return false;
          }
          if (v.isArray(obj)) {
            return obj.indexOf(value) !== -1;
          }
          return value in obj;
        },
        unique: function(array) {
          if (!v.isArray(array)) {
            return array;
          }
          return array.filter(function(el, index, array2) {
            return array2.indexOf(el) == index;
          });
        },
        forEachKeyInKeypath: function(object, keypath, callback) {
          if (!v.isString(keypath)) {
            return void 0;
          }
          var key = "", i, escape = false;
          for (i = 0; i < keypath.length; ++i) {
            switch (keypath[i]) {
              case ".":
                if (escape) {
                  escape = false;
                  key += ".";
                } else {
                  object = callback(object, key, false);
                  key = "";
                }
                break;
              case "\\":
                if (escape) {
                  escape = false;
                  key += "\\";
                } else {
                  escape = true;
                }
                break;
              default:
                escape = false;
                key += keypath[i];
                break;
            }
          }
          return callback(object, key, true);
        },
        getDeepObjectValue: function(obj, keypath) {
          if (!v.isObject(obj)) {
            return void 0;
          }
          return v.forEachKeyInKeypath(obj, keypath, function(obj2, key) {
            if (v.isObject(obj2)) {
              return obj2[key];
            }
          });
        },
        // This returns an object with all the values of the form.
        // It uses the input name as key and the value as value
        // So for example this:
        // <input type="text" name="email" value="foo@bar.com" />
        // would return:
        // {email: "foo@bar.com"}
        collectFormValues: function(form, options) {
          var values = {}, i, j, input, inputs, option, value;
          if (v.isJqueryElement(form)) {
            form = form[0];
          }
          if (!form) {
            return values;
          }
          options = options || {};
          inputs = form.querySelectorAll("input[name], textarea[name]");
          for (i = 0; i < inputs.length; ++i) {
            input = inputs.item(i);
            if (v.isDefined(input.getAttribute("data-ignored"))) {
              continue;
            }
            var name = input.name.replace(/\./g, "\\\\.");
            value = v.sanitizeFormValue(input.value, options);
            if (input.type === "number") {
              value = value ? +value : null;
            } else if (input.type === "checkbox") {
              if (input.attributes.value) {
                if (!input.checked) {
                  value = values[name] || null;
                }
              } else {
                value = input.checked;
              }
            } else if (input.type === "radio") {
              if (!input.checked) {
                value = values[name] || null;
              }
            }
            values[name] = value;
          }
          inputs = form.querySelectorAll("select[name]");
          for (i = 0; i < inputs.length; ++i) {
            input = inputs.item(i);
            if (v.isDefined(input.getAttribute("data-ignored"))) {
              continue;
            }
            if (input.multiple) {
              value = [];
              for (j in input.options) {
                option = input.options[j];
                if (option && option.selected) {
                  value.push(v.sanitizeFormValue(option.value, options));
                }
              }
            } else {
              var _val = typeof input.options[input.selectedIndex] !== "undefined" ? input.options[input.selectedIndex].value : (
                /* istanbul ignore next */
                ""
              );
              value = v.sanitizeFormValue(_val, options);
            }
            values[input.name] = value;
          }
          return values;
        },
        sanitizeFormValue: function(value, options) {
          if (options.trim && v.isString(value)) {
            value = value.trim();
          }
          if (options.nullify !== false && value === "") {
            return null;
          }
          return value;
        },
        capitalize: function(str) {
          if (!v.isString(str)) {
            return str;
          }
          return str[0].toUpperCase() + str.slice(1);
        },
        // Remove all errors who's error attribute is empty (null or undefined)
        pruneEmptyErrors: function(errors) {
          return errors.filter(function(error) {
            return !v.isEmpty(error.error);
          });
        },
        // In
        // [{error: ["err1", "err2"], ...}]
        // Out
        // [{error: "err1", ...}, {error: "err2", ...}]
        //
        // All attributes in an error with multiple messages are duplicated
        // when expanding the errors.
        expandMultipleErrors: function(errors) {
          var ret = [];
          errors.forEach(function(error) {
            if (v.isArray(error.error)) {
              error.error.forEach(function(msg) {
                ret.push(v.extend({}, error, { error: msg }));
              });
            } else {
              ret.push(error);
            }
          });
          return ret;
        },
        // Converts the error mesages by prepending the attribute name unless the
        // message is prefixed by ^
        convertErrorMessages: function(errors, options) {
          options = options || {};
          var ret = [], prettify = options.prettify || v.prettify;
          errors.forEach(function(errorInfo) {
            var error = v.result(
              errorInfo.error,
              errorInfo.value,
              errorInfo.attribute,
              errorInfo.options,
              errorInfo.attributes,
              errorInfo.globalOptions
            );
            if (!v.isString(error)) {
              ret.push(errorInfo);
              return;
            }
            if (error[0] === "^") {
              error = error.slice(1);
            } else if (options.fullMessages !== false) {
              error = v.capitalize(prettify(errorInfo.attribute)) + " " + error;
            }
            error = error.replace(/\\\^/g, "^");
            error = v.format(error, {
              value: v.stringifyValue(errorInfo.value, options)
            });
            ret.push(v.extend({}, errorInfo, { error }));
          });
          return ret;
        },
        // In:
        // [{attribute: "<attributeName>", ...}]
        // Out:
        // {"<attributeName>": [{attribute: "<attributeName>", ...}]}
        groupErrorsByAttribute: function(errors) {
          var ret = {};
          errors.forEach(function(error) {
            var list = ret[error.attribute];
            if (list) {
              list.push(error);
            } else {
              ret[error.attribute] = [error];
            }
          });
          return ret;
        },
        // In:
        // [{error: "<message 1>", ...}, {error: "<message 2>", ...}]
        // Out:
        // ["<message 1>", "<message 2>"]
        flattenErrorsToArray: function(errors) {
          return errors.map(function(error) {
            return error.error;
          }).filter(function(value, index, self) {
            return self.indexOf(value) === index;
          });
        },
        cleanAttributes: function(attributes, whitelist) {
          function whitelistCreator(obj, key, last) {
            if (v.isObject(obj[key])) {
              return obj[key];
            }
            return obj[key] = last ? true : {};
          }
          function buildObjectWhitelist(whitelist2) {
            var ow = {}, lastObject, attr;
            for (attr in whitelist2) {
              if (!whitelist2[attr]) {
                continue;
              }
              v.forEachKeyInKeypath(ow, attr, whitelistCreator);
            }
            return ow;
          }
          function cleanRecursive(attributes2, whitelist2) {
            if (!v.isObject(attributes2)) {
              return attributes2;
            }
            var ret = v.extend({}, attributes2), w, attribute;
            for (attribute in attributes2) {
              w = whitelist2[attribute];
              if (v.isObject(w)) {
                ret[attribute] = cleanRecursive(ret[attribute], w);
              } else if (!w) {
                delete ret[attribute];
              }
            }
            return ret;
          }
          if (!v.isObject(whitelist) || !v.isObject(attributes)) {
            return {};
          }
          whitelist = buildObjectWhitelist(whitelist);
          return cleanRecursive(attributes, whitelist);
        },
        exposeModule: function(validate2, root, exports3, module3, define3) {
          if (exports3) {
            if (module3 && module3.exports) {
              exports3 = module3.exports = validate2;
            }
            exports3.validate = validate2;
          } else {
            root.validate = validate2;
            if (validate2.isFunction(define3) && define3.amd) {
              define3([], function() {
                return validate2;
              });
            }
          }
        },
        warn: function(msg) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn("[validate.js] " + msg);
          }
        },
        error: function(msg) {
          if (typeof console !== "undefined" && console.error) {
            console.error("[validate.js] " + msg);
          }
        }
      });
      validate.validators = {
        // Presence validates that the value isn't empty
        presence: function(value, options) {
          options = v.extend({}, this.options, options);
          if (options.allowEmpty !== false ? !v.isDefined(value) : v.isEmpty(value)) {
            return options.message || this.message || "can't be blank";
          }
        },
        length: function(value, options, attribute) {
          if (!v.isDefined(value)) {
            return;
          }
          options = v.extend({}, this.options, options);
          var is = options.is, maximum = options.maximum, minimum = options.minimum, tokenizer = options.tokenizer || function(val) {
            return val;
          }, err, errors = [];
          value = tokenizer(value);
          var length = value.length;
          if (!v.isNumber(length)) {
            return options.message || this.notValid || "has an incorrect length";
          }
          if (v.isNumber(is) && length !== is) {
            err = options.wrongLength || this.wrongLength || "is the wrong length (should be %{count} characters)";
            errors.push(v.format(err, { count: is }));
          }
          if (v.isNumber(minimum) && length < minimum) {
            err = options.tooShort || this.tooShort || "is too short (minimum is %{count} characters)";
            errors.push(v.format(err, { count: minimum }));
          }
          if (v.isNumber(maximum) && length > maximum) {
            err = options.tooLong || this.tooLong || "is too long (maximum is %{count} characters)";
            errors.push(v.format(err, { count: maximum }));
          }
          if (errors.length > 0) {
            return options.message || errors;
          }
        },
        numericality: function(value, options, attribute, attributes, globalOptions) {
          if (!v.isDefined(value)) {
            return;
          }
          options = v.extend({}, this.options, options);
          var errors = [], name, count, checks = {
            greaterThan: function(v2, c) {
              return v2 > c;
            },
            greaterThanOrEqualTo: function(v2, c) {
              return v2 >= c;
            },
            equalTo: function(v2, c) {
              return v2 === c;
            },
            lessThan: function(v2, c) {
              return v2 < c;
            },
            lessThanOrEqualTo: function(v2, c) {
              return v2 <= c;
            },
            divisibleBy: function(v2, c) {
              return v2 % c === 0;
            }
          }, prettify = options.prettify || globalOptions && globalOptions.prettify || v.prettify;
          if (v.isString(value) && options.strict) {
            var pattern = "^-?(0|[1-9]\\d*)";
            if (!options.onlyInteger) {
              pattern += "(\\.\\d+)?";
            }
            pattern += "$";
            if (!new RegExp(pattern).test(value)) {
              return options.message || options.notValid || this.notValid || this.message || "must be a valid number";
            }
          }
          if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
            value = +value;
          }
          if (!v.isNumber(value)) {
            return options.message || options.notValid || this.notValid || this.message || "is not a number";
          }
          if (options.onlyInteger && !v.isInteger(value)) {
            return options.message || options.notInteger || this.notInteger || this.message || "must be an integer";
          }
          for (name in checks) {
            count = options[name];
            if (v.isNumber(count) && !checks[name](value, count)) {
              var key = "not" + v.capitalize(name);
              var msg = options[key] || this[key] || this.message || "must be %{type} %{count}";
              errors.push(v.format(msg, {
                count,
                type: prettify(name)
              }));
            }
          }
          if (options.odd && value % 2 !== 1) {
            errors.push(options.notOdd || this.notOdd || this.message || "must be odd");
          }
          if (options.even && value % 2 !== 0) {
            errors.push(options.notEven || this.notEven || this.message || "must be even");
          }
          if (errors.length) {
            return options.message || errors;
          }
        },
        datetime: v.extend(function(value, options) {
          if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
            throw new Error("Both the parse and format functions needs to be set to use the datetime/date validator");
          }
          if (!v.isDefined(value)) {
            return;
          }
          options = v.extend({}, this.options, options);
          var err, errors = [], earliest = options.earliest ? this.parse(options.earliest, options) : NaN, latest = options.latest ? this.parse(options.latest, options) : NaN;
          value = this.parse(value, options);
          if (isNaN(value) || options.dateOnly && value % 864e5 !== 0) {
            err = options.notValid || options.message || this.notValid || "must be a valid date";
            return v.format(err, { value: arguments[0] });
          }
          if (!isNaN(earliest) && value < earliest) {
            err = options.tooEarly || options.message || this.tooEarly || "must be no earlier than %{date}";
            err = v.format(err, {
              value: this.format(value, options),
              date: this.format(earliest, options)
            });
            errors.push(err);
          }
          if (!isNaN(latest) && value > latest) {
            err = options.tooLate || options.message || this.tooLate || "must be no later than %{date}";
            err = v.format(err, {
              date: this.format(latest, options),
              value: this.format(value, options)
            });
            errors.push(err);
          }
          if (errors.length) {
            return v.unique(errors);
          }
        }, {
          parse: null,
          format: null
        }),
        date: function(value, options) {
          options = v.extend({}, options, { dateOnly: true });
          return v.validators.datetime.call(v.validators.datetime, value, options);
        },
        format: function(value, options) {
          if (v.isString(options) || options instanceof RegExp) {
            options = { pattern: options };
          }
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is invalid", pattern = options.pattern, match;
          if (!v.isDefined(value)) {
            return;
          }
          if (!v.isString(value)) {
            return message;
          }
          if (v.isString(pattern)) {
            pattern = new RegExp(options.pattern, options.flags);
          }
          match = pattern.exec(value);
          if (!match || match[0].length != value.length) {
            return message;
          }
        },
        inclusion: function(value, options) {
          if (!v.isDefined(value)) {
            return;
          }
          if (v.isArray(options)) {
            options = { within: options };
          }
          options = v.extend({}, this.options, options);
          if (v.contains(options.within, value)) {
            return;
          }
          var message = options.message || this.message || "^%{value} is not included in the list";
          return v.format(message, { value });
        },
        exclusion: function(value, options) {
          if (!v.isDefined(value)) {
            return;
          }
          if (v.isArray(options)) {
            options = { within: options };
          }
          options = v.extend({}, this.options, options);
          if (!v.contains(options.within, value)) {
            return;
          }
          var message = options.message || this.message || "^%{value} is restricted";
          if (v.isString(options.within[value])) {
            value = options.within[value];
          }
          return v.format(message, { value });
        },
        email: v.extend(function(value, options) {
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is not a valid email";
          if (!v.isDefined(value)) {
            return;
          }
          if (!v.isString(value)) {
            return message;
          }
          if (!this.PATTERN.exec(value)) {
            return message;
          }
        }, {
          PATTERN: /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i
        }),
        equality: function(value, options, attribute, attributes, globalOptions) {
          if (!v.isDefined(value)) {
            return;
          }
          if (v.isString(options)) {
            options = { attribute: options };
          }
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is not equal to %{attribute}";
          if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
            throw new Error("The attribute must be a non empty string");
          }
          var otherValue = v.getDeepObjectValue(attributes, options.attribute), comparator = options.comparator || function(v1, v2) {
            return v1 === v2;
          }, prettify = options.prettify || globalOptions && globalOptions.prettify || v.prettify;
          if (!comparator(value, otherValue, options, attribute, attributes)) {
            return v.format(message, { attribute: prettify(options.attribute) });
          }
        },
        // A URL validator that is used to validate URLs with the ability to
        // restrict schemes and some domains.
        url: function(value, options) {
          if (!v.isDefined(value)) {
            return;
          }
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is not a valid url", schemes = options.schemes || this.schemes || ["http", "https"], allowLocal = options.allowLocal || this.allowLocal || false, allowDataUrl = options.allowDataUrl || this.allowDataUrl || false;
          if (!v.isString(value)) {
            return message;
          }
          var regex = "^(?:(?:" + schemes.join("|") + ")://)(?:\\S+(?::\\S*)?@)?(?:";
          var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
          if (allowLocal) {
            tld += "?";
          } else {
            regex += // IP address exclusion
            // private & local networks
            "(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})";
          }
          regex += // IP address dotted notation octets
          // excludes loopback network 0.0.0.0
          // excludes reserved space >= 224.0.0.0
          // excludes network & broacast addresses
          // (first & last IP address of each class)
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" + tld + ")(?::\\d{2,5})?(?:[/?#]\\S*)?$";
          if (allowDataUrl) {
            var mediaType = "\\w+\\/[-+.\\w]+(?:;[\\w=]+)*";
            var urlchar = "[A-Za-z0-9-_.!~\\*'();\\/?:@&=+$,%]*";
            var dataurl = "data:(?:" + mediaType + ")?(?:;base64)?," + urlchar;
            regex = "(?:" + regex + ")|(?:^" + dataurl + "$)";
          }
          var PATTERN = new RegExp(regex, "i");
          if (!PATTERN.exec(value)) {
            return message;
          }
        },
        type: v.extend(function(value, originalOptions, attribute, attributes, globalOptions) {
          if (v.isString(originalOptions)) {
            originalOptions = { type: originalOptions };
          }
          if (!v.isDefined(value)) {
            return;
          }
          var options = v.extend({}, this.options, originalOptions);
          var type = options.type;
          if (!v.isDefined(type)) {
            throw new Error("No type was specified");
          }
          var check;
          if (v.isFunction(type)) {
            check = type;
          } else {
            check = this.types[type];
          }
          if (!v.isFunction(check)) {
            throw new Error("validate.validators.type.types." + type + " must be a function.");
          }
          if (!check(value, options, attribute, attributes, globalOptions)) {
            var message = originalOptions.message || this.messages[type] || this.message || options.message || (v.isFunction(type) ? "must be of the correct type" : "must be of type %{type}");
            if (v.isFunction(message)) {
              message = message(value, originalOptions, attribute, attributes, globalOptions);
            }
            return v.format(message, { attribute: v.prettify(attribute), type });
          }
        }, {
          types: {
            object: function(value) {
              return v.isObject(value) && !v.isArray(value);
            },
            array: v.isArray,
            integer: v.isInteger,
            number: v.isNumber,
            string: v.isString,
            date: v.isDate,
            boolean: v.isBoolean
          },
          messages: {}
        })
      };
      validate.formatters = {
        detailed: function(errors) {
          return errors;
        },
        flat: v.flattenErrorsToArray,
        grouped: function(errors) {
          var attr;
          errors = v.groupErrorsByAttribute(errors);
          for (attr in errors) {
            errors[attr] = v.flattenErrorsToArray(errors[attr]);
          }
          return errors;
        },
        constraint: function(errors) {
          var attr;
          errors = v.groupErrorsByAttribute(errors);
          for (attr in errors) {
            errors[attr] = errors[attr].map(function(result) {
              return result.validator;
            }).sort();
          }
          return errors;
        }
      };
      validate.exposeModule(validate, this, exports2, module2, define2);
    }).call(
      exports,
      typeof exports !== "undefined" ? (
        /* istanbul ignore next */
        exports
      ) : null,
      typeof module !== "undefined" ? (
        /* istanbul ignore next */
        module
      ) : null,
      typeof define !== "undefined" ? (
        /* istanbul ignore next */
        define
      ) : null
    );
  }
});

// node_modules/@hilma/tools/dist/ValidateTool.js
var import_validate = __toESM(require_validate());
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var CarmelValidate = {
  isObject: function(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  },
  mergeDeep: function(target, source) {
    var _this = this;
    var output = Object.assign({}, target);
    if (this.isObject(target) && this.isObject(source)) {
      Object.keys(source).forEach(function(key) {
        var _a, _b;
        if (_this.isObject(source[key])) {
          if (!(key in target)) {
            if (key !== "eTarget") {
              Object.assign(output, (_a = {}, _a[key] = source[key], _a));
            }
          } else {
            output[key] = _this.mergeDeep(target[key], source[key]);
          }
        } else {
          Object.assign(output, (_b = {}, _b[key] = source[key], _b));
        }
      });
    }
    return output;
  },
  runValidate: function(data, rules, whitelist, depth) {
    if (rules === void 0) {
      rules = null;
    }
    if (whitelist === void 0) {
      whitelist = null;
    }
    if (depth === void 0) {
      depth = 10;
    }
    if (depth < 0)
      throw new Error("TOO DEEP BRO." + depth);
    if (whitelist) {
      data = import_validate.default.cleanAttributes(data, whitelist);
    }
    var res;
    if (this.isObject(data)) {
      try {
        if (rules && rules.type) {
          if (rules.type !== "object" && !this.isObject(rules.type)) {
            throw new Error("WANTED " + rules.type + " GOT object.");
          } else
            delete rules.type;
        }
        rules = this.createDefaultRules(data, rules, depth);
        res = import_validate.default.validate(data, rules);
      } catch (err) {
        console.log(err);
        return { success: 0 };
      }
    } else {
      if (rules.eTarget && rules.eTarget.type === "number" && !data)
        return;
      return this.ValidateVar(data, rules);
    }
    if (res === void 0)
      return { data, success: 1 };
    console.log("ERROR:", res);
    return { success: 0 };
  },
  createDefaultRules: function(data, rules, depth, originPath) {
    if (originPath === void 0) {
      originPath = "";
    }
    if (depth < 0)
      throw "TOO DEEP BRO." + depth;
    if (!rules)
      rules = {};
    if (this.isObject(data))
      rules = this.getObjectRules(data, rules, depth, originPath);
    else if (import_validate.default.isArray(data))
      rules[originPath] = this.getArrayRules(data, rules[originPath], depth);
    else if (import_validate.default.isDate(data))
      rules[originPath] = this.getDateRules(rules[originPath]);
    else if (import_validate.default.isString(data))
      rules[originPath] = this.getStringRules(rules[originPath], originPath);
    else if (import_validate.default.isNumber(data))
      rules[originPath] = this.getNumberRules(rules[originPath]);
    return rules;
  },
  ValidateVar: function(data, rule) {
    if (this.isObject(data))
      return this.runValidate(data, rule);
    else if (import_validate.default.isArray(data)) {
      import_validate.default.single(data);
    }
    if (import_validate.default.isDate(data))
      rule = this.getDateRules();
    else if (import_validate.default.isString(data)) {
      rule = this.getStringRules(rule);
    } else if (import_validate.default.isNumber(data)) {
      rule = this.getNumberRules(rule);
    }
    if (import_validate.default.single(data, rule) === void 0) {
      return { success: 1 };
    } else {
      return { success: 0, rule: rule.format ? rule : __assign(__assign({}, rule), { format: { message: "כתובת לא מאומתת" } }) };
    }
  },
  getObjectRules: function(data, rules, depth, originKey) {
    var _this = this;
    if (depth === void 0) {
      depth = 0;
    }
    if (originKey === void 0) {
      originKey = "";
    }
    if (depth < 0)
      throw new Error("TOO DEEP BRO." + depth);
    var keys = Object.keys(data);
    if (keys.length > this.originRules.object.maximum) {
      throw new Error("DATA OUT OF RANGE");
    }
    if (!rules)
      rules = {};
    if (data) {
      if (originKey !== "")
        originKey += ".";
    }
    keys.map(function(key) {
      rules = _this.mergeDeep(rules, _this.createDefaultRules(data[key], rules, depth - 1, originKey + key));
    });
    return rules;
  },
  getArrayRules: function(data, rules, depth) {
    if (data.length > 100)
      throw new Error("DATA OUT OF RANGE");
    var extendedRules = {};
    if (rules && rules.extendedRules) {
      extendedRules = rules.extendedRules;
    }
    rules = import_validate.default.cleanAttributes(rules, this.rulesWhitelist);
    if (data.length) {
      var type = typeof data[0];
      var res = void 0;
      for (var i = 0; i < data.length; i++) {
        if (extendedRules.consistent && typeof data[i] !== type)
          throw new Error("ARRAY DOES NOT CONATINS CONSISTENT DATA");
        res = this.runValidate(data[i], extendedRules[i] || extendedRules.all, null, depth - 1);
        if (!res.success)
          throw res;
      }
    }
    return {
      length: { minimum: 0, maximum: 100 }
    };
  },
  getDateRules: function() {
  },
  getStringRules: function(rule, originPath) {
    if (rule === void 0) {
      rule = {};
    }
    if (originPath === void 0) {
      originPath = "";
    }
    if (originPath.split(".").pop() === "email")
      return { email: true, length: { maximum: 100 } };
    if (rule.email) {
      return this.mergeDeep({
        length: { maximum: 1e4 }
      }, rule);
    }
    if (rule.eTarget && rule.eTarget.type === "password") {
      return this.mergeDeep(this.originRules.password, rule);
    }
    return this.mergeDeep(this.originRules.string, rule);
  },
  getNumberRules: function(rule) {
    if (rule === void 0) {
      rule = null;
    }
    if (!rule)
      rule = {};
    rule = import_validate.default.cleanAttributes(rule, this.rulesWhitelist);
    if (rule.type && rule.type === "number" || !rule.type) {
      var newRules = {
        type: "number",
        numericality: {
          greaterThan: -1e10,
          lessThanOrEqualTo: 1e10
        }
      };
      return this.mergeDeep(newRules, rule);
    } else
      return rule;
  },
  originRules: {
    array: {
      range: {
        min: 0,
        max: 100
      }
    },
    object: {
      maximum: 30
    },
    number: {
      range: {
        min: -1e9,
        max: 1e9
      }
    },
    string: {
      format: {
        pattern: "[a-z0-9א-ת -:._]*",
        flags: "i",
        message: "חייב להכיל אותיות או מספרים בלבד"
      },
      length: { maximum: 1e4 }
    },
    password: {
      format: {
        pattern: "(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{8,}",
        message: "הסיסמה חייבת להכיל אות קטנה ואות גדולה באנגלית מספר ולהיות באורך של 8 ספרות "
      },
      length: { maximum: 1e4 }
    }
  },
  rulesWhitelist: {
    earliest: true,
    latest: true,
    dateOnly: true,
    equality: true,
    email: true,
    length: true,
    exclusion: true,
    inclusion: true,
    message: true,
    format: true,
    numericality: true,
    presence: true,
    type: true,
    url: true
  }
};
var ValidateTool_default = CarmelValidate;

// node_modules/@hilma/tools/dist/AsyncTools.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var AsyncTools = {
  to: function(promise) {
    return __awaiter(this, void 0, void 0, function() {
      var data, error_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2, , 3]);
            return [4, promise];
          case 1:
            data = _a.sent();
            return [2, [null, data]];
          case 2:
            error_1 = _a.sent();
            return [2, [error_1, null]];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  },
  parseJSON: function(response) {
    return __awaiter(this, void 0, void 0, function() {
      var json, error_2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2, , 3]);
            return [4, response.json()];
          case 1:
            json = _a.sent();
            return [2, { status: response.status, ok: response.ok, json }];
          case 2:
            error_2 = _a.sent();
            if (response.status === 204 || response.status === 201)
              return [2, { status: response.status, ok: response.ok, json: { ok: response.ok } }];
            throw error_2;
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  },
  fetch: function(input, init) {
    return __awaiter(this, void 0, void 0, function() {
      var response, data;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, fetch(input, init)];
          case 1:
            response = _a.sent();
            return [4, this.parseJSON(response)];
          case 2:
            data = _a.sent();
            if (data.ok)
              return [2, data.json];
            throw data.json;
        }
      });
    });
  },
  superFetch: function(input, init) {
    return __awaiter(this, void 0, void 0, function() {
      var _a, error, data;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, this.to(this.fetch(input, init))];
          case 1:
            _a = _b.sent(), error = _a[0], data = _a[1];
            return [2, [data, error]];
        }
      });
    });
  }
};
var AsyncTools_default = AsyncTools;

// node_modules/@hilma/tools/dist/ValidateFields.js
function validateNameInput(input, required, placeholder) {
  if (placeholder === void 0) {
    placeholder = "שם";
  }
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס " + placeholder;
  else if (input.length > 20)
    return "חייב להכיל פחות מ20 תווים";
  else {
    var res = /[\u0590-\u05FF   \"\-\'a-zA-Z]*/i.exec(input);
    if (res[0] !== input)
      return "חייב להכיל רק אותיות";
  }
  return "";
}
function validateUsernameInput(input, required, placeholder) {
  if (placeholder === void 0) {
    placeholder = "שם משתמש";
  }
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס " + placeholder;
  else if (input.length > 20)
    return placeholder + " חייב להכיל פחות מ20 תווים";
  else {
    var res = /[a-z0-9\u0590-\u05FF_.-]*/i.exec(input);
    if (res[0] !== input)
      return placeholder + " חייב להכיל רק אותיות ומספרים";
  }
  return "";
}
function validateFullNameInput(input, required) {
  var res = /[\u0590-\u05FF \" \' \s]*/i.exec(input);
  if (input && !input.length && !required)
    return "";
  else if (input.length > 30)
    return "השם חייב להכיל פחות מ30 תווים";
  else if (res[0] !== input)
    return "השם חייב להכיל רק אותיות בעברית";
  else if (!input || !input.length || !/[\u0590-\u05FF \" \' \s]\s{1,}[\s \" \' \u0590-\u05FF]/.test(input))
    return "אנא הכנס שם פרטי ושם משפחה";
  return "";
}
function validatePhoneInput(input, required, length) {
  if (length === void 0) {
    length = 10;
  }
  input = input.replace(/[^0-9]/g, "");
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס מספר טלפון (ספרות בלבד)";
  else if (input.length !== length)
    return "מספר הטלפון חייב להכיל בדיוק " + length + " תווים";
  else if (!/^0\(?([0-9]{1,2})\)?([ -]?)([0-9]{3})\2([0-9]{4})/.test(input))
    return "מספר הטלפון לא תקין (ספרות בלבד)";
  return "";
}
function validateEmailInput(input, required) {
  var regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{1,}))$/;
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס כתובת מייל";
  else if (!regex.test(input))
    return "כתובת המייל שגויה";
  return "";
}
function validatePasswordInput(input, required) {
  var regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&#^().~`\[\]{}\|\\-_=+<>:"?])[A-Za-z\d@$!%*?&#^().~`\[\]{}\|\\-_=+<>:"?]{8,}$/;
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס סיסמא";
  else if (input.length < 8)
    return "הסיסמא חייבת להכיל לפחות 8 תווים";
  else if (!regex.test(input))
    return "הסיסמא חייבת להכיל מספר, תו מיוחד, אות גדולה ואות קטנה באנגלית";
  return "";
}
function validateConfirmPasswordInput(input, required, pw) {
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס אימות סיסמא";
  if (input !== pw)
    return "הסיסמאות אינן תואמות";
  return "";
}
function validateSelectInput(input, required, placeholder) {
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא בחר " + placeholder;
  return "";
}
function validateStringInput(input, required, placeholder, length) {
  if ((!input || !input.length) && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס " + placeholder;
  else if (input.length > length)
    return "חייב להכיל פחות מ" + length + " תווים";
  return "";
}
function validateAddressInput(input, required) {
  var res = /['\u0590-\u05FF \s 0-9]*/i.exec(input);
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס כתובת ומספר בית";
  else if (!/\d/.test(input) || res[0] !== input || !/['\u0590-\u05FF]/.test(input))
    return "חייב להכיל כתובת בעברית ומספר";
  else if (!/^['\u0590-\u05FF ]* [0-9]*[0-9  ]$/.test(input) && !/^[0-9  ][0-9]* ['\u0590-\u05FF ]*$/.test(input))
    return "כתובת המגורים שהזנת שגויה";
  return "";
}
var maxIntValue = 999999999;
function validateNumberInput(input, required, placeholder) {
  if (input && !input.length && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס " + placeholder;
  else if (input <= 0)
    return "על ה" + placeholder + " להיות גדול מ-0";
  else if (input > maxIntValue)
    return "על ה" + placeholder + " להכיל עד 9 ספרות";
  else if (!Number.isInteger(Number(input)))
    return "על ה" + placeholder + " להיות מספר שלם";
  return "";
}
function validateYoutubePathInput(input, required) {
  if ((!input || !input.length) && !required)
    return "";
  else if (!input || !input.length)
    return "אנא הכנס קישור";
  else if (!/^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/.test(input))
    return "הקישור שהזנת שגוי";
  return "";
}
var ValidateFields_default = {
  validateFullNameInput,
  validateNameInput,
  validatePhoneInput,
  validateEmailInput,
  validatePasswordInput,
  validateConfirmPasswordInput,
  validateSelectInput,
  validateStringInput,
  validateAddressInput,
  validateNumberInput,
  validateUsernameInput,
  validateYoutubePathInput
};

// node_modules/@hilma/tools/dist/react/getDisplayName.js
var getDisplayName = function(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || "Component";
};
var getDisplayName_default = getDisplayName;

// node_modules/@hilma/tools/dist/react/withContext.js
var import_react = __toESM(require_react());
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var withContext = function(mapContextToProps) {
  return function(component) {
    return Object.entries(mapContextToProps).reduceRight(function(component2, _a) {
      var key = _a[0], Context = _a[1];
      var WithContext = function(props) {
        var _a2;
        var value = (0, import_react.useContext)(Context);
        return (0, import_react.createElement)(component2, __assign2(__assign2({}, props), (_a2 = {}, _a2[key] = value, _a2)));
      };
      WithContext.displayName = "withContext(" + getDisplayName_default(component2) + ")";
      return WithContext;
    }, component);
  };
};
var withContext_default = withContext;

// node_modules/@hilma/tools/dist/react/wrap.js
var React2 = __toESM(require_react());

// node_modules/@hilma/tools/dist/react/isRenderable.js
var React = __toESM(require_react());
function isRenderable(arg) {
  return React.isValidElement(arg) || typeof arg === "number" || typeof arg === "string" || typeof arg === "boolean" || arg === null || arg === void 0 || arg instanceof Array;
}

// node_modules/@hilma/tools/dist/react/wrap.js
function wrap() {
  var parents = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    parents[_i] = arguments[_i];
  }
  return function(child, props) {
    return parents.reduceRight(function(acc, cur) {
      if (cur instanceof Array) {
        return React2.createElement(cur[0], cur[1], acc);
      }
      return React2.createElement(cur, null, acc);
    }, isRenderable(child) ? child : React2.createElement(child, props));
  };
}
var wrap_default = wrap;

// node_modules/@hilma/tools/dist/react/provide.js
function provide() {
  var parents = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    parents[_i] = arguments[_i];
  }
  return function(child) {
    return function(props) {
      return wrap_default.apply(void 0, parents)(child, props);
    };
  };
}
var provide_default = provide;

// node_modules/@hilma/tools/dist/react/createMobXContext.js
var import_react2 = __toESM(require_react());
var createMobXContext = function(storeInstance) {
  var StoreContext = (0, import_react2.createContext)(null);
  var StoreProvider = function(_a) {
    var children = _a.children;
    return (0, import_react2.createElement)(StoreContext.Provider, { value: storeInstance }, children);
  };
  StoreProvider.displayName = storeInstance.constructor.name + "Provider";
  var useStore = function() {
    var store = (0, import_react2.useContext)(StoreContext);
    if (!store)
      throw new Error("Trying to access " + storeInstance.constructor.name + " outside of provider");
    return store;
  };
  return [StoreContext, StoreProvider, useStore];
};
var createMobXContext_default = createMobXContext;

// node_modules/@hilma/tools/dist/react/hooks/useAsyncEffect.js
var import_react3 = __toESM(require_react());
var useAsyncEffect = function(effect, deps) {
  var cleanUpRef = (0, import_react3.useRef)();
  (0, import_react3.useEffect)(function() {
    cleanUpRef.current = void 0;
    var cleanUp = effect();
    if (cleanUp instanceof Promise)
      cleanUp.then(function(cleanUp2) {
        return cleanUpRef.current = cleanUp2;
      });
    else
      cleanUpRef.current = cleanUp;
    return function() {
      cleanUpRef.current && cleanUpRef.current();
    };
  }, deps);
};
var useAsyncEffect_default = useAsyncEffect;

// node_modules/@hilma/tools/dist/react/hooks/useMemoOnce.js
var import_react4 = __toESM(require_react());
var useMemoOnce = function(factory) {
  return (0, import_react4.useMemo)(factory, []);
};
var useMemoOnce_default = useMemoOnce;

// node_modules/@hilma/tools/dist/react/hooks/useCallbackOnce.js
var import_react5 = __toESM(require_react());
var useCallbackOnce = function(callback) {
  return (0, import_react5.useCallback)(callback, []);
};
var useCallbackOnce_default = useCallbackOnce;

// node_modules/@hilma/tools/dist/react/hooks/useAsyncState.js
var import_react6 = __toESM(require_react());
var useAsyncState = function(initialState) {
  var _a = (0, import_react6.useState)(initialState), state = _a[0], setState = _a[1];
  var resolveRef = (0, import_react6.useRef)(null);
  var callbackRef = (0, import_react6.useRef)(null);
  var setAsyncState = useCallbackOnce_default(function(value, callback) {
    resolveRef.current = null;
    callbackRef.current = null;
    return new Promise(function(resolve) {
      resolveRef.current = resolve;
      if (callback)
        callbackRef.current = callback;
      setState(function(prevState) {
        var newState = value instanceof Function ? value(prevState) : value;
        if (prevState === newState) {
          resolveRef.current = null;
          callbackRef.current = null;
          resolve(newState);
          callback && callback(newState);
        }
        return newState;
      });
    });
  });
  var getState = useCallbackOnce_default(function() {
    return new Promise(function(resolve) {
      setState(function(state2) {
        resolve(state2);
        return state2;
      });
    });
  });
  (0, import_react6.useEffect)(function() {
    resolveRef.current && resolveRef.current(state);
    callbackRef.current && callbackRef.current(state);
  }, [state]);
  return [state, setAsyncState, getState];
};
var useAsyncState_default = useAsyncState;

// node_modules/@hilma/tools/dist/functions/isCapacitor.js
var isCapacitor = function() {
  try {
    return window.Capacitor && (window.Capacitor.platform === "android" || window.Capacitor.platform === "ios") || window.forceCapacitor;
  } catch (error) {
    return false;
  }
};
var isCapacitor_default = isCapacitor;
export {
  AsyncTools_default as AsyncTools,
  ValidateTool_default as CarmelValidate,
  ValidateFields_default as ValidateFields,
  createMobXContext_default as createMobXContext,
  getDisplayName_default as getDisplayName,
  isCapacitor_default as isCapacitor,
  provide_default as provide,
  useAsyncEffect_default as useAsyncEffect,
  useAsyncState_default as useAsyncState,
  useCallbackOnce_default as useCallbackOnce,
  useMemoOnce_default as useMemoOnce,
  withContext_default as withContext,
  wrap_default as wrap
};
/*! Bundled license information:

validate.js/validate.js:
  (*!
   * validate.js 0.13.1
   *
   * (c) 2013-2019 Nicklas Ansman, 2013 Wrapp
   * Validate.js may be freely distributed under the MIT license.
   * For all details and documentation:
   * http://validatejs.org/
   *)
*/
//# sourceMappingURL=@hilma_tools.js.map
